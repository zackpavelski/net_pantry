'use strict';

var ByteArrayOutputStream = require('../io/ByteArrayOutputStream.js');
var Base64EncodeOutputStream = require('../io/Base64EncodeOutputStream.js');

/**
 * @module GIF Image (B/W)
 * @author nuintun
 * @author Kazuhiko Arase
 */
function encodeToBase64(data) {
    var output = new ByteArrayOutputStream.ByteArrayOutputStream();
    var stream = new Base64EncodeOutputStream.Base64EncodeOutputStream(output);
    stream.writeBytes(data);
    stream.close();
    output.close();
    return output.toByteArray();
}
var LZWTable = /*#__PURE__*/ (function () {
    function LZWTable() {
        this.size = 0;
        this.map = {};
    }
    LZWTable.prototype.add = function (key) {
        if (!this.contains(key)) {
            this.map[key] = this.size++;
        }
    };
    LZWTable.prototype.getSize = function () {
        return this.size;
    };
    LZWTable.prototype.indexOf = function (key) {
        return this.map[key];
    };
    LZWTable.prototype.contains = function (key) {
        return this.map[key] >= 0;
    };
    return LZWTable;
}());
var BitOutputStream = /*#__PURE__*/ (function () {
    function BitOutputStream(output) {
        this.output = output;
        this.bitLength = 0;
    }
    BitOutputStream.prototype.write = function (data, length) {
        if (data >>> length !== 0) {
            throw new Error('length overflow');
        }
        while (this.bitLength + length >= 8) {
            this.output.writeByte(0xff & ((data << this.bitLength) | this.bitBuffer));
            length -= 8 - this.bitLength;
            data >>>= 8 - this.bitLength;
            this.bitBuffer = 0;
            this.bitLength = 0;
        }
        this.bitBuffer = (data << this.bitLength) | this.bitBuffer;
        this.bitLength = this.bitLength + length;
    };
    BitOutputStream.prototype.flush = function () {
        if (this.bitLength > 0) {
            this.output.writeByte(this.bitBuffer);
        }
        this.output.flush();
    };
    BitOutputStream.prototype.close = function () {
        this.flush();
        this.output.close();
    };
    return BitOutputStream;
}());
var GIFImage = /*#__PURE__*/ (function () {
    function GIFImage(width, height) {
        this.data = [];
        this.width = width;
        this.height = height;
        var size = width * height;
        for (var i = 0; i < size; i++) {
            this.data[i] = 0;
        }
    }
    GIFImage.prototype.getLZWRaster = function (lzwMinCodeSize) {
        var clearCode = 1 << lzwMinCodeSize;
        var endCode = (1 << lzwMinCodeSize) + 1;
        // Setup LZWTable
        var table = new LZWTable();
        for (var i = 0; i < clearCode; i++) {
            table.add(String.fromCharCode(i));
        }
        table.add(String.fromCharCode(clearCode));
        table.add(String.fromCharCode(endCode));
        var byteOutput = new ByteArrayOutputStream.ByteArrayOutputStream();
        var bitOutput = new BitOutputStream(byteOutput);
        var bitLength = lzwMinCodeSize + 1;
        try {
            // Clear code
            bitOutput.write(clearCode, bitLength);
            var dataIndex = 0;
            var s = String.fromCharCode(this.data[dataIndex++]);
            var length_1 = this.data.length;
            while (dataIndex < length_1) {
                var c = String.fromCharCode(this.data[dataIndex++]);
                if (table.contains(s + c)) {
                    s = s + c;
                }
                else {
                    bitOutput.write(table.indexOf(s), bitLength);
                    if (table.getSize() < 0xfff) {
                        if (table.getSize() === 1 << bitLength) {
                            bitLength++;
                        }
                        table.add(s + c);
                    }
                    s = c;
                }
            }
            bitOutput.write(table.indexOf(s), bitLength);
            // End code
            bitOutput.write(endCode, bitLength);
        }
        finally {
            bitOutput.close();
        }
        return byteOutput.toByteArray();
    };
    GIFImage.prototype.writeWord = function (output, i) {
        output.writeByte(i & 0xff);
        output.writeByte((i >>> 8) & 0xff);
    };
    GIFImage.prototype.writeBytes = function (output, bytes, off, length) {
        for (var i = 0; i < length; i++) {
            output.writeByte(bytes[i + off]);
        }
    };
    GIFImage.prototype.setPixel = function (x, y, pixel) {
        if (x < 0 || this.width <= x)
            throw new Error("illegal x axis: " + x);
        if (y < 0 || this.height <= y)
            throw new Error("illegal y axis: " + y);
        this.data[y * this.width + x] = pixel;
    };
    GIFImage.prototype.getPixel = function (x, y) {
        if (x < 0 || this.width <= x)
            throw new Error("illegal x axis: " + x);
        if (y < 0 || this.height <= y)
            throw new Error("illegal y axis: " + y);
        return this.data[y * this.width + x];
    };
    GIFImage.prototype.write = function (output) {
        // GIF Signature
        output.writeByte(0x47); // G
        output.writeByte(0x49); // I
        output.writeByte(0x46); // F
        output.writeByte(0x38); // 8
        output.writeByte(0x37); // 7
        output.writeByte(0x61); // a
        // Screen Descriptor
        this.writeWord(output, this.width);
        this.writeWord(output, this.height);
        output.writeByte(0x80); // 2bit
        output.writeByte(0);
        output.writeByte(0);
        // Global Color Map
        // Black
        output.writeByte(0x00);
        output.writeByte(0x00);
        output.writeByte(0x00);
        // White
        output.writeByte(0xff);
        output.writeByte(0xff);
        output.writeByte(0xff);
        // Image Descriptor
        output.writeByte(0x2c); // ,
        this.writeWord(output, 0);
        this.writeWord(output, 0);
        this.writeWord(output, this.width);
        this.writeWord(output, this.height);
        output.writeByte(0);
        // Local Color Map
        // Raster Data
        var lzwMinCodeSize = 2;
        var raster = this.getLZWRaster(lzwMinCodeSize);
        var raLength = raster.length;
        output.writeByte(lzwMinCodeSize);
        var offset = 0;
        while (raLength - offset > 255) {
            output.writeByte(255);
            this.writeBytes(output, raster, offset, 255);
            offset += 255;
        }
        var length = raLength - offset;
        output.writeByte(length);
        this.writeBytes(output, raster, offset, length);
        output.writeByte(0x00);
        // GIF Terminator
        output.writeByte(0x3b); // ;
    };
    GIFImage.prototype.toDataURL = function () {
        var output = new ByteArrayOutputStream.ByteArrayOutputStream();
        this.write(output);
        var bytes = encodeToBase64(output.toByteArray());
        output.close();
        var url = 'data:image/gif;base64,';
        var length = bytes.length;
        for (var i = 0; i < length; i++) {
            url += String.fromCharCode(bytes[i]);
        }
        return url;
    };
    return GIFImage;
}());

exports.GIFImage = GIFImage;
