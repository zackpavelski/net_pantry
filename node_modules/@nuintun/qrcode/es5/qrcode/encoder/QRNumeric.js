'use strict';

var Mode = require('../common/Mode.js');
var tslib = require('tslib');
var QRData = require('./QRData.js');
var UTF16 = require('../../encoding/UTF16.js');

/**
 * @module QRNumeric
 * @author nuintun
 * @author Kazuhiko Arase
 */
function getCode(byte) {
    // 0 - 9
    if (0x30 <= byte && byte <= 0x39) {
        return byte - 0x30;
    }
    throw new Error("illegal char: " + String.fromCharCode(byte));
}
function getBatchCode(bytes) {
    var num = 0;
    var length = bytes.length;
    for (var i = 0; i < length; i++) {
        num = num * 10 + getCode(bytes[i]);
    }
    return num;
}
var QRNumeric = /*#__PURE__*/ (function (_super) {
    tslib.__extends(QRNumeric, _super);
    /**
     * @constructor
     * @param {string} data
     */
    function QRNumeric(data) {
        var _this = _super.call(this, Mode.Mode.Numeric, data) || this;
        _this.bytes = UTF16.UTF16(data);
        return _this;
    }
    /**
     * @public
     * @method write
     * @param {BitBuffer} buffer
     */
    QRNumeric.prototype.write = function (buffer) {
        var i = 0;
        var bytes = this.bytes;
        var length = bytes.length;
        while (i + 2 < length) {
            buffer.put(getBatchCode([bytes[i], bytes[i + 1], bytes[i + 2]]), 10);
            i += 3;
        }
        if (i < length) {
            if (length - i === 1) {
                buffer.put(getBatchCode([bytes[i]]), 4);
            }
            else if (length - i === 2) {
                buffer.put(getBatchCode([bytes[i], bytes[i + 1]]), 7);
            }
        }
    };
    /**
     * @public
     * @method getLength
     * @returns {number}
     */
    QRNumeric.prototype.getLength = function () {
        return this.bytes.length;
    };
    return QRNumeric;
}(QRData.QRData));

exports.QRNumeric = QRNumeric;
