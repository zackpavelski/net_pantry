import { Mode as Mode$1 } from '../common/Mode.js';
import { QRData as QRData$1 } from './QRData.js';
import { QRByte as QRByte$1 } from './QRByte.js';
import { Polynomial as Polynomial$1 } from './Polynomial.js';
import { getAlignmentPattern, getBCHVersion, calculateMaskPenalty, getErrorCorrectionPolynomial, getBCHVersionInfo } from './QRUtil.js';
import { ErrorCorrectionLevel as ErrorCorrectionLevel$1 } from '../common/ErrorCorrectionLevel.js';
import { RSBlock as RSBlock$1 } from './RSBlock.js';
import { BitBuffer as BitBuffer$1 } from './BitBuffer.js';
import { GIFImage as GIFImage$1 } from '../../image/GIFImage.js';
import { getMaskFunc } from '../common/MaskPattern.js';

/**
 * @module QRCode
 * @author nuintun
 * @author Kazuhiko Arase
 */
var PAD0 = 0xec;
var PAD1 = 0x11;
var toString = Object.prototype.toString;
/**
 * @function appendECI
 * @param {number} encoding
 * @param {BitBuffer} buffer
 * @see https://github.com/nayuki/QR-Code-generator/blob/master/typescript/qrcodegen.ts
 * @see https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/qrcode/encoder/Encoder.java
 */
function appendECI(encoding, buffer) {
    if (encoding < 0 || encoding >= 1000000) {
        throw new Error('byte mode encoding hint out of range');
    }
    buffer.put(Mode$1.ECI, 4);
    if (encoding < 1 << 7) {
        buffer.put(encoding, 8);
    }
    else if (encoding < 1 << 14) {
        buffer.put(2, 2);
        buffer.put(encoding, 14);
    }
    else {
        buffer.put(6, 3);
        buffer.put(encoding, 21);
    }
}
function prepareData(version, errorCorrectionLevel, encodingHint, chunks) {
    var dLength = chunks.length;
    var buffer = new BitBuffer$1();
    var rsBlocks = RSBlock$1.getRSBlocks(version, errorCorrectionLevel);
    for (var i = 0; i < dLength; i++) {
        var data = chunks[i];
        var mode = data.getMode();
        // Default set encoding UTF-8 when has encoding hint
        if (encodingHint && mode === Mode$1.Byte) {
            appendECI(data.encoding, buffer);
        }
        buffer.put(mode, 4);
        buffer.put(data.getLength(), data.getLengthInBits(version));
        data.write(buffer);
    }
    // Calc max data count
    var maxDataCount = 0;
    var rLength = rsBlocks.length;
    for (var i = 0; i < rLength; i++) {
        maxDataCount += rsBlocks[i].getDataCount();
    }
    maxDataCount *= 8;
    return [buffer, rsBlocks, maxDataCount];
}
function createBytes(buffer, rsBlocks) {
    var offset = 0;
    var maxDcCount = 0;
    var maxEcCount = 0;
    var dcData = [];
    var ecData = [];
    var rsLength = rsBlocks.length;
    var bufferData = buffer.getBuffer();
    for (var r = 0; r < rsLength; r++) {
        var rsBlock = rsBlocks[r];
        var dcCount = rsBlock.getDataCount();
        var ecCount = rsBlock.getTotalCount() - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcData[r] = [];
        for (var i = 0; i < dcCount; i++) {
            dcData[r][i] = 0xff & bufferData[i + offset];
        }
        offset += dcCount;
        var rsPoly = getErrorCorrectionPolynomial(ecCount);
        var ecLength = rsPoly.getLength() - 1;
        var rawPoly = new Polynomial$1(dcData[r], ecLength);
        var modPoly = rawPoly.mod(rsPoly);
        var mpLength = modPoly.getLength();
        ecData[r] = [];
        for (var i = 0; i < ecLength; i++) {
            var modIndex = i + mpLength - ecLength;
            ecData[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
        }
    }
    buffer = new BitBuffer$1();
    for (var i = 0; i < maxDcCount; i++) {
        for (var r = 0; r < rsLength; r++) {
            if (i < dcData[r].length) {
                buffer.put(dcData[r][i], 8);
            }
        }
    }
    for (var i = 0; i < maxEcCount; i++) {
        for (var r = 0; r < rsLength; r++) {
            if (i < ecData[r].length) {
                buffer.put(ecData[r][i], 8);
            }
        }
    }
    return buffer;
}
function createData(buffer, rsBlocks, maxDataCount) {
    if (buffer.getLengthInBits() > maxDataCount) {
        throw new Error("data overflow: " + buffer.getLengthInBits() + " > " + maxDataCount);
    }
    // End
    if (buffer.getLengthInBits() + 4 <= maxDataCount) {
        buffer.put(0, 4);
    }
    // Padding
    while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(false);
    }
    // Padding
    while (true) {
        if (buffer.getLengthInBits() >= maxDataCount) {
            break;
        }
        buffer.put(PAD0, 8);
        if (buffer.getLengthInBits() >= maxDataCount) {
            break;
        }
        buffer.put(PAD1, 8);
    }
    return createBytes(buffer, rsBlocks);
}
var Encoder = /*#__PURE__*/ (function () {
    function Encoder() {
        this.version = 0;
        this.chunks = [];
        this.matrixSize = 0;
        this.matrix = [];
        this.encodingHint = false;
        this.auto = this.version === 0;
        this.errorCorrectionLevel = ErrorCorrectionLevel$1.L;
    }
    /**
     * @public
     * @method getMatrix
     * @returns {boolean[][]}
     */
    Encoder.prototype.getMatrix = function () {
        return this.matrix;
    };
    /**
     * @public
     * @method getMatrixSize
     * @returns {number}
     */
    Encoder.prototype.getMatrixSize = function () {
        return this.matrixSize;
    };
    /**
     * @public
     * @method getVersion
     * @returns {number}
     */
    Encoder.prototype.getVersion = function () {
        return this.version;
    };
    /**
     * @public
     * @method setVersion
     * @param {number} version
     * @returns {Encoder}
     */
    Encoder.prototype.setVersion = function (version) {
        this.version = Math.min(40, Math.max(0, version >> 0));
        this.auto = this.version === 0;
        return this;
    };
    /**
     * @public
     * @method getErrorCorrectionLevel
     * @returns {ErrorCorrectionLevel}
     */
    Encoder.prototype.getErrorCorrectionLevel = function () {
        return this.errorCorrectionLevel;
    };
    /**
     * @public
     * @method setErrorCorrectionLevel
     * @param {ErrorCorrectionLevel} errorCorrectionLevel
     */
    Encoder.prototype.setErrorCorrectionLevel = function (errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
            case ErrorCorrectionLevel$1.L:
            case ErrorCorrectionLevel$1.M:
            case ErrorCorrectionLevel$1.Q:
            case ErrorCorrectionLevel$1.H:
                this.errorCorrectionLevel = errorCorrectionLevel;
        }
        return this;
    };
    /**
     * @public
     * @method getEncodingHint
     * @returns {boolean}
     */
    Encoder.prototype.getEncodingHint = function () {
        return this.encodingHint;
    };
    /**
     * @public
     * @method setEncodingHint
     * @param {boolean} encodingHint
     * @returns {Encoder}
     */
    Encoder.prototype.setEncodingHint = function (encodingHint) {
        this.encodingHint = encodingHint;
        return this;
    };
    /**
     * @public
     * @method write
     * @param {QRData} data
     * @returns {Encoder}
     */
    Encoder.prototype.write = function (data) {
        if (data instanceof QRData$1) {
            this.chunks.push(data);
        }
        else {
            var type = toString.call(data);
            if (type === '[object String]') {
                this.chunks.push(new QRByte$1(data));
            }
            else {
                throw new Error("illegal data: " + data);
            }
        }
        return this;
    };
    /**
     * @public
     * @method isDark
     * @param {number} row
     * @param {number} col
     * @returns {boolean}
     */
    Encoder.prototype.isDark = function (row, col) {
        if (this.matrix[row][col] !== null) {
            return this.matrix[row][col];
        }
        else {
            return false;
        }
    };
    Encoder.prototype.setupFinderPattern = function (row, col) {
        var matrixSize = this.matrixSize;
        for (var r = -1; r <= 7; r++) {
            for (var c = -1; c <= 7; c++) {
                if (row + r <= -1 || matrixSize <= row + r || col + c <= -1 || matrixSize <= col + c) {
                    continue;
                }
                if ((0 <= r && r <= 6 && (c === 0 || c === 6)) ||
                    (0 <= c && c <= 6 && (r === 0 || r === 6)) ||
                    (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                    this.matrix[row + r][col + c] = true;
                }
                else {
                    this.matrix[row + r][col + c] = false;
                }
            }
        }
    };
    Encoder.prototype.setupAlignmentPattern = function () {
        var pos = getAlignmentPattern(this.version);
        var length = pos.length;
        for (var i = 0; i < length; i++) {
            for (var j = 0; j < length; j++) {
                var row = pos[i];
                var col = pos[j];
                if (this.matrix[row][col] !== null) {
                    continue;
                }
                for (var r = -2; r <= 2; r++) {
                    for (var c = -2; c <= 2; c++) {
                        if (r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0)) {
                            this.matrix[row + r][col + c] = true;
                        }
                        else {
                            this.matrix[row + r][col + c] = false;
                        }
                    }
                }
            }
        }
    };
    Encoder.prototype.setupTimingPattern = function () {
        var count = this.matrixSize - 8;
        for (var i = 8; i < count; i++) {
            var bit = i % 2 === 0;
            // vertical
            if (this.matrix[i][6] === null) {
                this.matrix[i][6] = bit;
            }
            // horizontal
            if (this.matrix[6][i] === null) {
                this.matrix[6][i] = bit;
            }
        }
    };
    Encoder.prototype.setupFormatInfo = function (maskPattern) {
        var data = (this.errorCorrectionLevel << 3) | maskPattern;
        var bits = getBCHVersionInfo(data);
        var matrixSize = this.matrixSize;
        for (var i = 0; i < 15; i++) {
            var bit = ((bits >> i) & 1) === 1;
            // Vertical
            if (i < 6) {
                this.matrix[i][8] = bit;
            }
            else if (i < 8) {
                this.matrix[i + 1][8] = bit;
            }
            else {
                this.matrix[matrixSize - 15 + i][8] = bit;
            }
            // Horizontal
            if (i < 8) {
                this.matrix[8][matrixSize - i - 1] = bit;
            }
            else if (i < 9) {
                this.matrix[8][15 - i - 1 + 1] = bit;
            }
            else {
                this.matrix[8][15 - i - 1] = bit;
            }
        }
        // Fixed point
        this.matrix[matrixSize - 8][8] = true;
    };
    Encoder.prototype.setupVersionInfo = function () {
        if (this.version >= 7) {
            var matrixSize = this.matrixSize;
            var bits = getBCHVersion(this.version);
            for (var i = 0; i < 18; i++) {
                var bit = ((bits >> i) & 1) === 1;
                this.matrix[(i / 3) >> 0][(i % 3) + matrixSize - 8 - 3] = bit;
                this.matrix[(i % 3) + matrixSize - 8 - 3][(i / 3) >> 0] = bit;
            }
        }
    };
    Encoder.prototype.setupCodewords = function (data, maskPattern) {
        var matrixSize = this.matrixSize;
        var bitLength = data.getLengthInBits();
        // Bit index into the data
        var bitIndex = 0;
        // Do the funny zigzag scan
        for (var right = matrixSize - 1; right >= 1; right -= 2) {
            // Index of right column in each column pair
            if (right === 6) {
                right = 5;
            }
            for (var vert = 0; vert < matrixSize; vert++) {
                // Vertical counter
                for (var j = 0; j < 2; j++) {
                    // Actual x coordinate
                    var x = right - j;
                    var upward = ((right + 1) & 2) === 0;
                    // Actual y coordinate
                    var y = upward ? matrixSize - 1 - vert : vert;
                    if (this.matrix[y][x] !== null) {
                        continue;
                    }
                    var bit = false;
                    if (bitIndex < bitLength) {
                        bit = data.getBit(bitIndex++);
                    }
                    var maskFunc = getMaskFunc(maskPattern);
                    var invert = maskFunc(x, y);
                    if (invert) {
                        bit = !bit;
                    }
                    this.matrix[y][x] = bit;
                }
            }
        }
    };
    Encoder.prototype.buildMatrix = function (data, maskPattern) {
        // Initialize matrix
        this.matrix = [];
        var matrixSize = this.matrixSize;
        for (var row = 0; row < matrixSize; row++) {
            this.matrix[row] = [];
            for (var col = 0; col < matrixSize; col++) {
                this.matrix[row][col] = null;
            }
        }
        // Setup finder pattern
        this.setupFinderPattern(0, 0);
        this.setupFinderPattern(matrixSize - 7, 0);
        this.setupFinderPattern(0, matrixSize - 7);
        // Setup alignment pattern
        this.setupAlignmentPattern();
        // Setup timing pattern
        this.setupTimingPattern();
        // Setup format info
        this.setupFormatInfo(maskPattern);
        // Setup version info
        this.setupVersionInfo();
        // Setup codewords
        this.setupCodewords(data, maskPattern);
    };
    /**
     * @public
     * @method make
     * @returns {Encoder}
     */
    Encoder.prototype.make = function () {
        var _a, _b;
        var buffer;
        var rsBlocks;
        var maxDataCount;
        var chunks = this.chunks;
        var errorCorrectionLevel = this.errorCorrectionLevel;
        if (this.auto) {
            for (this.version = 1; this.version <= 40; this.version++) {
                _a = prepareData(this.version, errorCorrectionLevel, this.encodingHint, chunks), buffer = _a[0], rsBlocks = _a[1], maxDataCount = _a[2];
                if (buffer.getLengthInBits() <= maxDataCount)
                    break;
            }
        }
        else {
            _b = prepareData(this.version, errorCorrectionLevel, this.encodingHint, chunks), buffer = _b[0], rsBlocks = _b[1], maxDataCount = _b[2];
        }
        // Calc module count
        this.matrixSize = this.version * 4 + 17;
        var matrices = [];
        var data = createData(buffer, rsBlocks, maxDataCount);
        var bestMaskPattern = -1;
        var minPenalty = Number.MAX_VALUE;
        // Choose best mask pattern
        for (var maskPattern = 0; maskPattern < 8; maskPattern++) {
            this.buildMatrix(data, maskPattern);
            matrices.push(this.matrix);
            var penalty = calculateMaskPenalty(this);
            if (penalty < minPenalty) {
                minPenalty = penalty;
                bestMaskPattern = maskPattern;
            }
        }
        this.matrix = matrices[bestMaskPattern];
        return this;
    };
    /**
     * @public
     * @method toDataURL
     * @param {number} moduleSize
     * @param {number} margin
     * @returns {string}
     */
    Encoder.prototype.toDataURL = function (moduleSize, margin) {
        if (moduleSize === void 0) { moduleSize = 2; }
        if (margin === void 0) { margin = moduleSize * 4; }
        moduleSize = Math.max(1, moduleSize >> 0);
        margin = Math.max(0, margin >> 0);
        var matrixSize = this.matrixSize;
        var size = moduleSize * matrixSize + margin * 2;
        var gif = new GIFImage$1(size, size);
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (margin <= x &&
                    x < size - margin &&
                    margin <= y &&
                    y < size - margin &&
                    this.isDark(((y - margin) / moduleSize) >> 0, ((x - margin) / moduleSize) >> 0)) {
                    gif.setPixel(x, y, 0);
                }
                else {
                    gif.setPixel(x, y, 1);
                }
            }
        }
        return gif.toDataURL();
    };
    return Encoder;
}());

export { Encoder };
